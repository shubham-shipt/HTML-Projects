<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        /* Header for UI elements */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .ui-element {
            padding: 8px;
            font-size: 16px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            color: #fff;
            box-shadow: 0 0 15px rgba(30, 227, 207, 0.5), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        @keyframes glowPulse {
            0% { box-shadow: 0 0 15px rgba(30, 227, 207, 0.5), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
            50% { box-shadow: 0 0 25px rgba(30, 227, 207, 0.8), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
            100% { box-shadow: 0 0 15px rgba(30, 227, 207, 0.5), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
        }

        .ui-element:hover {
            transform: scale(1.05);
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
        }

        .ui-element:active {
            transform: scale(0.95);
        }

        button.ui-element {
            padding: 8px 16px;
            background: linear-gradient(145deg, #1EE3CF, #6B48FF);
            color: #fff;
        }

        button.ui-element:hover {
            background: linear-gradient(145deg, #6B48FF, #1EE3CF);
        }

        #color-picker {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            color: #fff;
            padding: 8px;
            font-size: 16px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #color-picker option {
            background: #333;
            color: #fff;
        }

        #custom-color-picker {
            width: 40px;
            height: 40px;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
        }

        /* Tooltip styling */
        .ui-element::after {
            content: attr(data-tooltip);
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .ui-element:hover::after {
            opacity: 1;
        }

        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                padding: 5px;
                gap: 5px;
            }
            .ui-element {
                font-size: 14px;
                padding: 6px;
                width: 90%;
                margin: 0 auto;
            }
            button.ui-element {
                padding: 6px 12px;
                width: 90%;
                margin: 0 auto;
            }
            #color-picker {
                font-size: 14px;
                padding: 6px;
                width: 90%;
                margin: 0 auto;
            }
            #custom-color-picker {
                width: 40px;
                height: 30px;
                margin: 0 auto;
            }
            .ui-element::after {
                font-size: 10px;
                top: -25px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <input type="text" id="name-input" class="ui-element" placeholder="Enter your name" maxlength="20" role="textbox" aria-label="Enter your name" data-tooltip="Enter text to visualize">
        <select id="color-picker" class="ui-element" aria-label="Select particle color" data-tooltip="Choose particle color scheme">
            <option value="default">Choose Color</option>
            <option value="pinkGlow">Pink Glow</option>
            <option value="blueSpark">Blue Spark</option>
            <option value="goldenFlare">Golden Flare</option>
            <option value="emeraldShine">Emerald Shine</option>
            <option value="violetBurst">Violet Burst</option>
        </select>
        <input type="color" id="custom-color-picker" class="ui-element" aria-label="Custom color picker" data-tooltip="Pick a custom color">
        <input type="range" id="density-slider" class="ui-element" min="1" max="10" value="2" aria-label="Adjust particle density" data-tooltip="Adjust particle density">
        <input type="range" id="speed-slider" class="ui-element" min="0.1" max="5" step="0.1" value="1" aria-label="Adjust animation speed" data-tooltip="Adjust animation speed">
        <button id="submit" class="ui-element" role="button" aria-label="Submit input" data-tooltip="Start visualization">Submit</button>
        <button id="reset" class="ui-element" role="button" aria-label="Reset input" data-tooltip="Reset to default">Reset</button>
        <button id="toggle-rotate" class="ui-element" role="button" aria-label="Toggle auto rotation" data-tooltip="Toggle auto rotation">Toggle Rotate</button>
        <button id="export-image" class="ui-element" role="button" aria-label="Export as image" data-tooltip="Export as image">Export Image</button>
    </div>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 color;
        attribute float fade;
      
        varying vec3 vColor;
      
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size;
          gl_Position = projectionMatrix * mvPosition;
        }
    </script>
      
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
          gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
    <script src="https://assets.codepen.io/127738/MeshSurfaceSampler_20210711.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>
    <script>
        const pixelRatio = window.innerWidth < 600 ? 1 : 2;
        let maxParticles = window.innerWidth < 600 ? 50000 : 100000;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.001,
          1000
        );
        camera.position.set(0, 1, 2.7);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);

        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 0.4;

        const composer = new THREE.EffectComposer(renderer);
        composer.setPixelRatio(pixelRatio);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.rotateSpeed = 1.5;
        controls.maxDistance = 5;
        controls.minDistance = 0.5;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const group = new THREE.Group();
        scene.add(group);

        let omText = null;
        let sampler = null;
        let sparkles = [];
        const lines = [];
        let colors = [
          new THREE.Color("#CFD6DE"),
          new THREE.Color("#1EE3CF"),
          new THREE.Color("#6B48FF"),
          new THREE.Color("#125D98")
        ];
        let galaxyColors = [
          new THREE.Color("#CFD6DE").multiplyScalar(0.5),
          new THREE.Color("#1EE3CF").multiplyScalar(0.5),
          new THREE.Color("#6B48FF").multiplyScalar(0.5),
          new THREE.Color("#125D98").multiplyScalar(0.5)
        ];

        let animationSpeed = 1;

        const sparklesGeometry = new THREE.BufferGeometry();
        const sparklesMaterial = new THREE.ShaderMaterial({
          uniforms: {
            pointTexture: {
              value: new THREE.TextureLoader().load(
                "https://assets.codepen.io/127738/dotTexture.png"
              )
            }
          },
          vertexShader: document.getElementById("vertexshader").textContent,
          fragmentShader: document.getElementById("fragmentshader").textContent,
          blending: THREE.AdditiveBlending,
          alphaTest: 1.0,
          transparent: true
        });
        const points = new THREE.Points(sparklesGeometry, sparklesMaterial);
        group.add(points);

        function addText(text) {
            if (omText) group.remove(omText);
            sparkles = [];
            lines.forEach(line => group.remove(line));
            lines.length = 0;

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                const textLength = text.length;
                const size = textLength > 10 ? 1 / (textLength * 0.03) : 1;
                const textGeometry = new THREE.TextGeometry(text || 'OM', {
                    font: font,
                    size: size,
                    height: 0.2,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                textGeometry.computeBoundingBox();
                const centerOffset = textGeometry.boundingBox.getCenter(new THREE.Vector3()).negate();
                textGeometry.translate(centerOffset.x, centerOffset.y, centerOffset.z);
                omText = new THREE.Mesh(textGeometry);
                omText.visible = false;
                group.add(omText);
                group.position.set(0, 0, 0);
                dots();
                for (let i = 0; i < 100; i++) {
                    lines.forEach(line => nextDot(line));
                }
                updateSparklesGeometry();
            });
        }

        // Function to detect the operating system
        function getOperatingSystem() {
            const userAgent = navigator.userAgent.toLowerCase();
            if (userAgent.includes("android")) {
                return "Android";
            } else if (userAgent.includes("windows")) {
                return "Windows";
            } else if (userAgent.includes("linux") && !userAgent.includes("android")) {
                return "Linux";
            }
            return "Unknown";
        }

        document.getElementById('submit').addEventListener('click', () => {
            const userInput = document.getElementById('name-input').value.trim().toUpperCase();
            if (userInput) {
                addText(userInput);

                // Check OS and hide UI buttons if on Android
                const os = getOperatingSystem();
                if (os === "Android") {
                    const header = document.querySelector('.header');
                    header.style.display = 'none';
                }
            } else {
                alert("Please enter a name to visualize!");
            }
        });

        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('name-input').value = '';
            addText('OM');
        });

        let autoRotate = true;
        document.getElementById('toggle-rotate').addEventListener('click', () => {
            autoRotate = !autoRotate;
            document.getElementById('toggle-rotate').textContent = autoRotate ? 'Toggle Rotate (On)' : 'Toggle Rotate (Off)';
        });

        document.getElementById('export-image').addEventListener('click', () => {
            composer.render();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = window.innerWidth * pixelRatio;
            tempCanvas.height = window.innerHeight * pixelRatio;
            const context = tempCanvas.getContext('2d');
            context.drawImage(renderer.domElement, 0, 0, tempCanvas.width, tempCanvas.height);
            const dataURL = tempCanvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'sh_images.png';
            link.click();
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
        });

        document.getElementById('density-slider').addEventListener('input', (e) => {
            const newMaxParticles = parseInt(e.target.value) * (window.innerWidth < 600 ? 5000 : 10000);
            if (newMaxParticles < maxParticles) {
                sparkles = sparkles.slice(0, newMaxParticles);
                updateSparklesGeometry();
            }
            maxParticles = newMaxParticles;
        });

        function updateButtonGradients() {
            const buttons = document.querySelectorAll('button.ui-element');
            buttons.forEach(button => {
                const color1 = colors[0].getStyle();
                const color2 = colors[1].getStyle();
                button.style.background = `linear-gradient(145deg, ${color1}, ${color2})`;
                button.style.setProperty('--hover-gradient', `linear-gradient(145deg, ${color2}, ${color1})`);
            });

            const styleSheet = document.styleSheets[0];
            const glowRuleIndex = Array.from(styleSheet.cssRules).findIndex(rule => rule.name === 'glowPulse');
            if (glowRuleIndex !== -1) {
                styleSheet.deleteRule(glowRuleIndex);
            }
            const color1 = colors[0];
            styleSheet.insertRule(`
                @keyframes glowPulse {
                    0% { box-shadow: 0 0 15px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 0.5), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
                    50% { box-shadow: 0 0 25px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 0.8), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
                    100% { box-shadow: 0 0 15px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 0.5), inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(255, 255, 255, 0.1); }
                }
            `, glowRuleIndex === -1 ? styleSheet.cssRules.length : glowRuleIndex);

            const hoverRuleIndex = Array.from(styleSheet.cssRules).findIndex(rule => rule.selectorText === 'button.ui-element:hover');
            if (hoverRuleIndex !== -1) {
                styleSheet.deleteRule(hoverRuleIndex);
            }
            styleSheet.insertRule(`
                button.ui-element:hover {
                    background: var(--hover-gradient);
                }
            `, hoverRuleIndex === -1 ? styleSheet.cssRules.length : hoverRuleIndex);
        }

        document.getElementById('color-picker').addEventListener('change', (e) => {
            const scheme = e.target.value;
            if (scheme === 'pinkGlow') {
                colors = [
                    new THREE.Color("#FF69B4"),
                    new THREE.Color("#FF1493"),
                    new THREE.Color("#FFC1CC"),
                    new THREE.Color("#FF85A2")
                ];
                galaxyColors = [
                    new THREE.Color("#FF69B4").multiplyScalar(0.5),
                    new THREE.Color("#FF1493").multiplyScalar(0.5),
                    new THREE.Color("#FFC1CC").multiplyScalar(0.5),
                    new THREE.Color("#FF85A2").multiplyScalar(0.5)
                ];
            } else if (scheme === 'blueSpark') {
                colors = [
                    new THREE.Color("#00BFFF"),
                    new THREE.Color("#1E90FF"),
                    new THREE.Color("#87CEEB"),
                    new THREE.Color("#4682B4")
                ];
                galaxyColors = [
                    new THREE.Color("#00BFFF").multiplyScalar(0.5),
                    new THREE.Color("#1E90FF").multiplyScalar(0.5),
                    new THREE.Color("#87CEEB").multiplyScalar(0.5),
                    new THREE.Color("#4682B4").multiplyScalar(0.5)
                ];
            } else if (scheme === 'goldenFlare') {
                colors = [
                    new THREE.Color("#FFD700"),
                    new THREE.Color("#FFA500"),
                    new THREE.Color("#FFEC8B"),
                    new THREE.Color("#DAA520")
                ];
                galaxyColors = [
                    new THREE.Color("#FFD700").multiplyScalar(0.5),
                    new THREE.Color("#FFA500").multiplyScalar(0.5),
                    new THREE.Color("#FFEC8B").multiplyScalar(0.5),
                    new THREE.Color("#DAA520").multiplyScalar(0.5)
                ];
            } else if (scheme === 'emeraldShine') {
                colors = [
                    new THREE.Color("#00FF7F"),
                    new THREE.Color("#20B2AA"),
                    new THREE.Color("#3CB371"),
                    new THREE.Color("#66CDAA")
                ];
                galaxyColors = [
                    new THREE.Color("#00FF7F").multiplyScalar(0.5),
                    new THREE.Color("#20B2AA").multiplyScalar(0.5),
                    new THREE.Color("#3CB371").multiplyScalar(0.5),
                    new THREE.Color("#66CDAA").multiplyScalar(0.5)
                ];
            } else if (scheme === 'violetBurst') {
                colors = [
                    new THREE.Color("#8A2BE2"),
                    new THREE.Color("#DA70D6"),
                    new THREE.Color("#EE82EE"),
                    new THREE.Color("#DDA0DD")
                ];
                galaxyColors = [
                    new THREE.Color("#8A2BE2").multiplyScalar(0.5),
                    new THREE.Color("#DA70D6").multiplyScalar(0.5),
                    new THREE.Color("#EE82EE").multiplyScalar(0.5),
                    new THREE.Color("#DDA0DD").multiplyScalar(0.5)
                ];
            } else {
                colors = [
                    new THREE.Color("#CFD6DE"),
                    new THREE.Color("#1EE3CF"),
                    new THREE.Color("#6B48FF"),
                    new THREE.Color("#125D98")
                ];
                galaxyColors = [
                    new THREE.Color("#CFD6DE").multiplyScalar(0.5),
                    new THREE.Color("#1EE3CF").multiplyScalar(0.5),
                    new THREE.Color("#6B48FF").multiplyScalar(0.5),
                    new THREE.Color("#125D98").multiplyScalar(0.5)
                ];
            }
            updateColors();
            updateButtonGradients();
        });

        document.getElementById('custom-color-picker').addEventListener('input', (e) => {
            const selectedColor = e.target.value;
            const color = new THREE.Color(selectedColor);
            colors = [
                color,
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.2),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.4),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.6)
            ];
            galaxyColors = [
                color.clone().multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.2).multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.4).multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.6).multiplyScalar(0.5)
            ];
            updateColors();
            updateButtonGradients();
        });

        function updateColors() {
            lines.forEach((line, i) => {
                line.material.color = colors[i % colors.length];
            });
            sparkles.forEach((sparkle, i) => {
                sparkle.color = colors[i % colors.length];
            });
            updateSparklesGeometry();
            let tempGalaxyColors = [];
            stars.forEach((star, i) => {
                star.color = galaxyColors[i % galaxyColors.length];
                tempGalaxyColors.push(star.color.r, star.color.g, star.color.b);
            });
            starsGeometry.setAttribute(
                "color",
                new THREE.Float32BufferAttribute(tempGalaxyColors, 3)
            );
        }

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyE':
                    moveUp = true;
                    break;
                case 'KeyQ':
                    moveDown = true;
                    break;
                case 'NumpadAdd':
                case 'Equal':
                    camera.position.z -= 0.1;
                    break;
                case 'NumpadSubtract':
                case 'Minus':
                    camera.position.z += 0.1;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'KeyE':
                    moveUp = false;
                    break;
                case 'KeyQ':
                    moveDown = false;
                    break;
            }
        });

        document.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.005;
            camera.position.z = Math.max(0.5, Math.min(5, camera.position.z));
        });

        function updateCamera() {
            const speed = 0.05;
            if (moveForward) camera.position.z -= speed;
            if (moveBackward) camera.position.z += speed;
            if (moveLeft) camera.position.x -= speed;
            if (moveRight) camera.position.x += speed;
            if (moveUp) camera.position.y += speed;
            if (moveDown) camera.position.y -= speed;

            camera.position.z = Math.max(0.5, Math.min(5, camera.position.z));
        }

        function dots() {
            if (!omText) return;
            sampler = new THREE.MeshSurfaceSampler(omText).build();

            for (let i = 0; i < 8; i++) {
                const linesMaterial = new THREE.LineBasicMaterial({
                    color: colors[i % 4],
                    transparent: true,
                    opacity: 1
                });
                const linesMesh = new THREE.Line(new THREE.BufferGeometry(), linesMaterial);
                linesMesh.coordinates = [];
                linesMesh.previous = null;
                lines.push(linesMesh);
                group.add(linesMesh);
            }
        }

        let safe = 0;
        const p1 = new THREE.Vector3();
        function nextDot(line) {
            let ok = false;
            safe = 0;
            while (!ok && safe < 300 * animationSpeed) {
                sampler.sample(p1);
                if (line.previous && p1.distanceTo(line.previous) < 0.08) {
                    line.coordinates.push(p1.x, p1.y, p1.z);
                    line.previous = p1.clone();

                    if (sparkles.length < maxParticles) {
                        for (let i = 0; i < 2; i++) {
                            const spark = new Sparkle();
                            spark.setup(p1, line.material.color);
                            sparkles.push(spark);
                        }
                    }
                    ok = true;
                } else if (!line.previous) {
                    line.previous = p1.clone();
                }
                safe++;
            }
        }

        function updateSparklesGeometry() {
            let tempSparklesArraySizes = [];
            let tempSparklesArrayColors = [];
            let tempSparklesArrayPositions = [];
            sparkles.forEach((s) => {
                tempSparklesArraySizes.push(s.size);
                tempSparklesArrayColors.push(s.color.r, s.color.g, s.color.b);
                tempSparklesArrayPositions.push(s.x, s.y, s.z);
            });
            sparklesGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(tempSparklesArrayPositions, 3)
            );
            sparklesGeometry.setAttribute(
                "color",
                new THREE.Float32BufferAttribute(tempSparklesArrayColors, 3)
            );
            sparklesGeometry.setAttribute(
                "size",
                new THREE.Float32BufferAttribute(tempSparklesArraySizes, 1)
            );
            sparklesGeometry.attributes.position.needsUpdate = true;
            sparklesGeometry.attributes.color.needsUpdate = true;
            sparklesGeometry.attributes.size.needsUpdate = true;
        }

        class Sparkle extends THREE.Vector3 {
            constructor() {
                super();
                this.age = 0;
                this.dead = false;
            }
            setup(origin, color) {
                this.x = origin.x;
                this.y = origin.y;
                this.z = origin.z;
                this.v = new THREE.Vector3();
                this.v.x = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.x *= Math.random() > 0.5 ? 1 : -1;
                this.v.y = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.y *= Math.random() > 0.5 ? 1 : -1;
                this.v.z = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.z *= Math.random() > 0.5 ? 1 : -1;

                this.size = Math.random() * 4 + 0.5 * pixelRatio;
                this.slowDown = 0.4 + Math.random() * 0.58;
                this.color = color;
            }
            update() {
                this.age++;
                if (this.age > 300 / animationSpeed) {
                    this.dead = true;
                    return;
                }
                if (this.v.x > 0.001 || this.v.y > 0.001 || this.v.z > 0.001) {
                    this.add(this.v);
                    this.v.multiplyScalar(this.slowDown);
                }
            }
        }

        class Star {
            setup(color) {
                this.r = Math.random() * 3 + 1;
                this.phi = Math.random() * Math.PI * 2;
                this.theta = Math.random() * Math.PI;
                this.v = new THREE.Vector2().random().subScalar(0.5).multiplyScalar(0.0007);

                this.x = this.r * Math.sin(this.phi) * Math.sin(this.theta);
                this.y = this.r * Math.cos(this.phi);
                this.z = this.r * Math.sin(this.phi) * Math.cos(this.theta);

                this.size = Math.random() * 4 + 0.5 * pixelRatio;
                this.color = color;
            }
            update() {
                this.phi += this.v.x * animationSpeed;
                this.theta += this.v.y * animationSpeed;
                this.x = this.r * Math.sin(this.phi) * Math.sin(this.theta);
                this.y = this.r * Math.cos(this.phi);
                this.z = this.r * Math.sin(this.phi) * Math.cos(this.theta);
            }
        }

        const stars = [];
        const galaxyGeometryVertices = [];
        const galaxyGeometryColors = [];
        const galaxyGeometrySizes = [];

        for (let i = 0; i < (window.innerWidth < 600 ? 500 : 1000); i++) {
            const star = new Star();
            star.setup(galaxyColors[Math.floor(Math.random() * galaxyColors.length)]);
            galaxyGeometryVertices.push(star.x, star.y, star.z);
            galaxyGeometryColors.push(star.color.r, star.color.g, star.color.b);
            galaxyGeometrySizes.push(star.size);
            stars.push(star);
        }
        const starsGeometry = new THREE.BufferGeometry();
        starsGeometry.setAttribute(
            "size",
            new THREE.Float32BufferAttribute(galaxyGeometrySizes, 1)
        );
        starsGeometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(galaxyGeometryColors, 3)
        );
        const galaxyPoints = new THREE.Points(starsGeometry, sparklesMaterial);
        scene.add(galaxyPoints);

        let _prev = 0;
        function render(a) {
            if (autoRotate) group.rotation.y += 0.001 * animationSpeed;

            galaxyPoints.rotation.y += 0.0005 * animationSpeed;

            if (a - _prev > 30 / animationSpeed) {
                lines.forEach((l) => {
                    if (sparkles.length < maxParticles) {
                        for (let i = 0; i < 2 * animationSpeed; i++) nextDot(l);
                    }
                    const tempVertices = new Float32Array(l.coordinates);
                    l.geometry.setAttribute(
                        "position",
                        new THREE.BufferAttribute(tempVertices, 3)
                    );
                    l.geometry.computeBoundingSphere();
                });
                sparkles = sparkles.filter(s => !s.dead);
                sparkles.forEach(s => s.update());
                updateSparklesGeometry();
                _prev = a;
            }

            let tempStarsArray = [];
            stars.forEach((s) => {
                s.update();
                tempStarsArray.push(s.x, s.y, s.z);
            });

            starsGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(tempStarsArray, 3)
            );

            updateCamera();
            controls.update();
            composer.render();
        }

        renderer.setAnimationLoop(render);

        window.addEventListener("resize", onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = function() {
            alert("Welcome to Particle Visualizer! Please enter a name and press the 'Submit' button to start the visualization.");
        };
    </script>
</body>
</html>
