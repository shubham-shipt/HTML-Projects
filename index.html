<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shineword</title>
    <link rel="icon" type="image/png" href="icons8-universe-16.png">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0a23 0%, #000000 100%);
            transition: background 0.5s ease;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            transition: background 0.5s ease;
        }

        .ui-element {
            padding: 5px;
            font-size: 14px;
            border: none;
            border-radius: 20px;
            background: linear-gradient(145deg, #2A5470, #4C4177);
            color: #e0e0e0;
            box-shadow: 0 0 10px rgba(44, 62, 80, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
            font-family: 'Montserrat', sans-serif;
        }

        .ui-element::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .ui-element:hover::before {
            left: 100%;
        }

        @keyframes neonPulse {
            0% { box-shadow: 0 0 10px rgba(44, 62, 80, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
            50% { box-shadow: 0 0 20px rgba(44, 62, 80, 1), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
            100% { box-shadow: 0 0 10px rgba(44, 62, 80, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
        }

        .ui-element:hover {
            transform: scale(1.03);
            animation: neonPulse 1.5s infinite;
        }

        .ui-element:active {
            transform: scale(0.97);
        }

        button.ui-element {
            padding: 5px 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
        }

        #name-input {
            background: linear-gradient(145deg, #2A5470, #4C4177);
            color: #e0e0e0;
            border: none;
            z-index: 101;
            font-family: 'Montserrat', sans-serif;
            transition: background 0.5s ease;
        }

        #color-picker {
            background: linear-gradient(145deg, #2A5470, #4C4177);
            color: #e0e0e0;
            padding: 5px;
            font-size: 14px;
            border-radius: 20px;
            border: none;
            z-index: 101;
            font-family: 'Montserrat', sans-serif;
            transition: background 0.5s ease;
        }

        #color-picker option {
            background: #222;
            color: #e0e0e0;
            font-family: 'Montserrat', sans-serif;
        }

        #custom-color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
            z-index: 101;
        }

        #toggle-header {
            position: fixed;
            top: 50px;
            right: 10px;
            z-index: 99;
            touch-action: none;
            display: block !important;
        }

        .ui-element::after {
            content: attr(data-tooltip);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #e0e0e0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .ui-element:hover::after {
            opacity: 1;
        }

        .custom-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a2e;
            color: #e0e0e0;
            border: 2px solid #4C4177;
            border-radius: 10px;
            padding: 15px 20px;
            z-index: 999;
            box-shadow: 0 0 20px rgba(78, 60, 125, 0.5);
            font-family: 'Montserrat', sans-serif;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .custom-alert button {
            margin-top: 10px;
            padding: 6px 14px;
            background: linear-gradient(145deg, #2A5470, #4C4177);
            color: #fff;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .custom-alert button:hover {
            background: #6B48FF;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                padding: 4px;
                gap: 4px;
                display: flex !important;
            }
            .ui-element {
                font-size: 12px;
                padding: 4px;
                width: 90%;
                margin: 0 auto;
            }
            button.ui-element {
                padding: 4px 8px;
                width: 90%;
                margin: 0 auto;
            }
            #name-input {
                width: 90%;
                margin: 0 auto;
                display: block !important;
            }
            #color-picker {
                font-size: 12px;
                padding: 4px;
                width: 90%;
                margin: 0 auto;
            }
            #custom-color-picker {
                width: 30px;
                height: 25px;
                margin: 0 auto;
            }
            .ui-element::after {
                font-size: 9px;
                top: -20px;
            }
            #toggle-header {
                top: 80px;
                right: 10px;
                z-index: 99;
                display: block !important;
                visibility: visible !important;
            }
            .custom-alert {
                top: 10px;
                padding: 10px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="custom-alert" class="custom-alert hidden">
        <p id="custom-alert-message"></p>
        <button onclick="hideCustomAlert()">OK</button>
    </div>

    <div class="header" id="header">
        <input type="text" id="name-input" class="ui-element" placeholder="Enter your name" maxlength="20" role="textbox" aria-label="Enter your name" data-tooltip="Enter text to visualize">
        <select id="color-picker" class="ui-element" aria-label="Select particle color" data-tooltip="Choose particle color scheme">
            <option value="default">Choose Color</option>
            <option value="pinkGlow">Pink Glow</option>
            <option value="blueSpark">Blue Spark</option>
            <option value="goldenFlare">Golden Flare</option>
            <option value="emeraldShine">Emerald Shine</option>
            <option value="violetBurst">Violet Burst</option>
        </select>
        <input type="color" id="custom-color-picker" class="ui-element" aria-label="Custom color picker" data-tooltip="Pick a custom color">
        <input type="range" id="density-slider" class="ui-element" min="1" max="10" value="2" aria-label="Adjust particle density" data-tooltip="Adjust particle density">
        <input type="range" id="speed-slider" class="ui-element" min="0.1" max="5" step="0.1" value="1" aria-label="Adjust animation speed" data-tooltip="Adjust animation speed">
        <button id="submit" class="ui-element" role="button" aria-label="Submit input" data-tooltip="Start visualization">Submit</button>
        <button id="reset" class="ui-element" role="button" aria-label="Reset input" data-tooltip="Reset to default">Reset</button>
        <button id="toggle-rotate" class="ui-element" role="button" aria-label="Toggle auto rotation" data-tooltip="Toggle auto rotation">Toggle Rotate</button>
        <button id="export-image" class="ui-element" role="button" aria-label="Export as image" data-tooltip="Export as image">Export Image</button>
    </div>
    <button id="toggle-header" class="ui-element" role="button" aria-label="Toggle header visibility" data-tooltip="Show/Hide Controls">Show Controls</button>

    <audio id="background-audio" loop preload="auto" volume="0.3">
        <source src="sound.mp3" type="audio/mpeg">
        Your browser does not support the audio element. Please try a different browser.
    </audio>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
      
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size;
          gl_Position = projectionMatrix * mvPosition;
        }
    </script>
      
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
          gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://assets.codepen.io/127738/MeshSurfaceSampler_20210711.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.3/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>
    <script>
        const pixelRatio = window.innerWidth < 600 ? 1 : 1.5;
        let maxParticles = window.innerWidth < 600 ? 30000 : 60000;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.001,
          1000
        );
        camera.position.set(0, 1, 2.7);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.setPixelRatio(pixelRatio);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.rotateSpeed = 1.5;
        controls.maxDistance = 10;
        controls.minDistance = 0.1;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const group = new THREE.Group();
        scene.add(group);

        let omText = null;
        let sampler = null;
        let sparkles = [];
        const lines = [];
        let colors = [
          new THREE.Color("#CFD6DE"),
          new THREE.Color("#1EE3CF"),
          new THREE.Color("#6B48FF"),
          new THREE.Color("#125D98")
        ];
        let galaxyColors = [
          new THREE.Color("#CFD6DE").multiplyScalar(0.5),
          new THREE.Color("#1EE3CF").multiplyScalar(0.5),
          new THREE.Color("#6B48FF").multiplyScalar(0.5),
          new THREE.Color("#125D98").multiplyScalar(0.5)
        ];

        let animationSpeed = 1;

        const sparklesGeometry = new THREE.BufferGeometry();
        const sparklesMaterial = new THREE.ShaderMaterial({
          uniforms: {
            pointTexture: {
              value: new THREE.TextureLoader().load(
                "https://assets.codepen.io/127738/dotTexture.png"
              )
            }
          },
          vertexShader: document.getElementById("vertexshader").textContent,
          fragmentShader: document.getElementById("fragmentshader").textContent,
          blending: THREE.AdditiveBlending,
          alphaTest: 1.0,
          transparent: true
        });
        const points = new THREE.Points(sparklesGeometry, sparklesMaterial);
        group.add(points);

        function addText(text) {
            if (omText) group.remove(omText);
            sparkles.length = 0;
            lines.forEach(line => group.remove(line));
            lines.length = 0;

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                const textLength = text.length;
                const size = textLength > 10 ? 1 / (textLength * 0.03) : 1;
                const textGeometry = new THREE.TextGeometry(text || 'OM', {
                    font: font,
                    size: size,
                    height: 0.2,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                textGeometry.computeBoundingBox();
                const centerOffset = textGeometry.boundingBox.getCenter(new THREE.Vector3()).negate();
                textGeometry.translate(centerOffset.x, centerOffset.y, centerOffset.z);
                omText = new THREE.Mesh(textGeometry);
                const sampler = new THREE.MeshSurfaceSampler(omText).build();
                omText.visible = false;
                group.add(omText);
                group.position.set(0, 0, 0);
                dots();
                for (let i = 0; i < 30; i++) {
                    lines.forEach(line => nextDot(line));
                }
                updateSparklesGeometry();
            });
        }

        const submitButton = document.getElementById('submit');
        submitButton.addEventListener('click', () => {
            const userInput = document.getElementById('name-input').value.trim().toUpperCase();
            if (userInput) {
                addText(userInput);
                if (/Android/i.test(navigator.userAgent)) {
                    document.getElementById('header').style.display = 'none';
                    document.getElementById('toggle-header').textContent = 'Show Controls';
                }
            } else {
                showCustomAlert("Please enter a name to visualize!");
            }
        });

        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('name-input').value = '';
            addText('OM');
        });

        let autoRotate = true;
        document.getElementById('toggle-rotate').addEventListener('click', () => {
            autoRotate = !autoRotate;
            document.getElementById('toggle-rotate').textContent = autoRotate ? 'Toggle Rotate (On)' : 'Toggle Rotate (Off)';
        });

        document.getElementById('export-image').addEventListener('click', () => {
            composer.render();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = window.innerWidth * pixelRatio;
            tempCanvas.height = window.innerHeight * pixelRatio;
            const context = tempCanvas.getContext('2d');
            context.drawImage(renderer.domElement, 0, 0, tempCanvas.width, tempCanvas.height);
            const dataURL = tempCanvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'sh_images.png';
            link.click();
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
        });

        document.getElementById('density-slider').addEventListener('input', (e) => {
            const newMaxParticles = parseInt(e.target.value) * (window.innerWidth < 600 ? 3000 : 6000);
            if (newMaxParticles < maxParticles) {
                sparkles = sparkles.slice(0, newMaxParticles);
                updateSparklesGeometry();
            }
            maxParticles = newMaxParticles;
        });

        const toggleHeaderButton = document.getElementById('toggle-header');
        let isDragging = false;
        let currentX, currentY, initialX, initialY;

        toggleHeaderButton.addEventListener('mousedown', startDragging);
        toggleHeaderButton.addEventListener('touchstart', startDragging);

        function startDragging(e) {
            isDragging = true;
            if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX - currentX;
                initialY = e.touches[0].clientY - currentY;
            } else {
                initialX = e.clientX - currentX;
                initialY = e.clientY - currentY;
            }
            toggleHeaderButton.style.cursor = 'grabbing';
        }

        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag);

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();
            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }
            toggleHeaderButton.style.left = currentX + 'px';
            toggleHeaderButton.style.top = currentY + 'px';
            toggleHeaderButton.style.right = 'auto';
        }

        document.addEventListener('mouseup', stopDragging);
        document.addEventListener('touchend', stopDragging);

        function stopDragging() {
            isDragging = false;
            toggleHeaderButton.style.cursor = 'pointer';
        }

        toggleHeaderButton.addEventListener('click', () => {
            const header = document.getElementById('header');
            if (header.style.display === 'none') {
                header.style.display = 'flex';
                toggleHeaderButton.textContent = 'Hide Controls';
            } else {
                header.style.display = 'none';
                toggleHeaderButton.textContent = 'Show Controls';
            }
            setTimeout(() => {
                header.style.display = header.style.display;
            }, 0);
        });

        if (/Android/i.test(navigator.userAgent)) {
            window.addEventListener('resize', () => {
                const header = document.getElementById('header');
                if (header.style.display !== 'none') {
                    header.style.display = 'flex';
                }
            });
        }

        function updateButtonGradients() {
            const buttons = document.querySelectorAll('button.ui-element');
            const nameInput = document.getElementById('name-input');
            const colorPicker = document.getElementById('color-picker');
            buttons.forEach(button => {
                const color1 = colors[0].getStyle();
                const color2 = colors[1].getStyle();
                button.style.background = `linear-gradient(145deg, ${color1}, ${color2})`;
                button.style.setProperty('--hover-gradient', `linear-gradient(145deg, ${color2}, ${color1})`);
            });
            nameInput.style.background = `linear-gradient(145deg, ${colors[0].getStyle()}, ${colors[1].getStyle()})`;
            colorPicker.style.background = `linear-gradient(145deg, ${colors[0].getStyle()}, ${colors[1].getStyle()})`;

            const styleSheet = document.styleSheets[0];
            const glowRuleIndex = Array.from(styleSheet.cssRules).findIndex(rule => rule.name === 'neonPulse');
            if (glowRuleIndex !== -1) {
                styleSheet.deleteRule(glowRuleIndex);
            }
            const color1 = colors[0];
            styleSheet.insertRule(`
                @keyframes neonPulse {
                    0% { box-shadow: 0 0 10px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
                    50% { box-shadow: 0 0 20px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 1), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
                    100% { box-shadow: 0 0 10px rgba(${color1.r * 255}, ${color1.g * 255}, ${color1.b * 255}, 0.5), inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.05); }
                }
            `, glowRuleIndex === -1 ? styleSheet.cssRules.length : glowRuleIndex);

            const hoverRuleIndex = Array.from(styleSheet.cssRules).findIndex(rule => rule.selectorText === 'button.ui-element:hover');
            if (hoverRuleIndex !== -1) {
                styleSheet.deleteRule(hoverRuleIndex);
            }
            styleSheet.insertRule(`
                button.ui-element:hover {
                    background: var(--hover-gradient);
                }
            `, hoverRuleIndex === -1 ? styleSheet.cssRules.length : hoverRuleIndex);

            document.body.style.background = `radial-gradient(circle at center, ${colors[0].getStyle()} 0%, #000000 100%)`;
        }

        document.getElementById('color-picker').addEventListener('change', (e) => {
            const scheme = e.target.value;
            if (scheme === 'pinkGlow') {
                colors = [
                    new THREE.Color("#FF69B4"),
                    new THREE.Color("#FF1493"),
                    new THREE.Color("#FFC1CC"),
                    new THREE.Color("#FF85A2")
                ];
                galaxyColors = [
                    new THREE.Color("#FF69B4").multiplyScalar(0.5),
                    new THREE.Color("#FF1493").multiplyScalar(0.5),
                    new THREE.Color("#FFC1CC").multiplyScalar(0.5),
                    new THREE.Color("#FF85A2").multiplyScalar(0.5)
                ];
            } else if (scheme === 'blueSpark') {
                colors = [
                    new THREE.Color("#00BFFF"),
                    new THREE.Color("#1E90FF"),
                    new THREE.Color("#87CEEB"),
                    new THREE.Color("#4682B4")
                ];
                galaxyColors = [
                    new THREE.Color("#00BFFF").multiplyScalar(0.5),
                    new THREE.Color("#1E90FF").multiplyScalar(0.5),
                    new THREE.Color("#87CEEB").multiplyScalar(0.5),
                    new THREE.Color("#4682B4").multiplyScalar(0.5)
                ];
            } else if (scheme === 'goldenFlare') {
                colors = [
                    new THREE.Color("#FFD700"),
                    new THREE.Color("#FFA500"),
                    new THREE.Color("#FFEC8B"),
                    new THREE.Color("#DAA520")
                ];
                galaxyColors = [
                    new THREE.Color("#FFD700").multiplyScalar(0.5),
                    new THREE.Color("#FFA500").multiplyScalar(0.5),
                    new THREE.Color("#FFEC8B").multiplyScalar(0.5),
                    new THREE.Color("#DAA520").multiplyScalar(0.5)
                ];
            } else if (scheme === 'emeraldShine') {
                colors = [
                    new THREE.Color("#00FF7F"),
                    new THREE.Color("#20B2AA"),
                    new THREE.Color("#3CB371"),
                    new THREE.Color("#66CDAA")
                ];
                galaxyColors = [
                    new THREE.Color("#00FF7F").multiplyScalar(0.5),
                    new THREE.Color("#20B2AA").multiplyScalar(0.5),
                    new THREE.Color("#3CB371").multiplyScalar(0.5),
                    new THREE.Color("#66CDAA").multiplyScalar(0.5)
                ];
            } else if (scheme === 'violetBurst') {
                colors = [
                    new THREE.Color("#8A2BE2"),
                    new THREE.Color("#DA70D6"),
                    new THREE.Color("#EE82EE"),
                    new THREE.Color("#DDA0DD")
                ];
                galaxyColors = [
                    new THREE.Color("#8A2BE2").multiplyScalar(0.5),
                    new THREE.Color("#DA70D6").multiplyScalar(0.5),
                    new THREE.Color("#EE82EE").multiplyScalar(0.5),
                    new THREE.Color("#DDA0DD").multiplyScalar(0.5)
                ];
            } else {
                colors = [
                    new THREE.Color("#CFD6DE"),
                    new THREE.Color("#1EE3CF"),
                    new THREE.Color("#6B48FF"),
                    new THREE.Color("#125D98")
                ];
                galaxyColors = [
                    new THREE.Color("#CFD6DE").multiplyScalar(0.5),
                    new THREE.Color("#1EE3CF").multiplyScalar(0.5),
                    new THREE.Color("#6B48FF").multiplyScalar(0.5),
                    new THREE.Color("#125D98").multiplyScalar(0.5)
                ];
            }
            updateColors();
            updateButtonGradients();
        });

        document.getElementById('custom-color-picker').addEventListener('input', (e) => {
            const selectedColor = e.target.value;
            const color = new THREE.Color(selectedColor);
            colors = [
                color,
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.2),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.4),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.6)
            ];
            galaxyColors = [
                color.clone().multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.2).multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.4).multiplyScalar(0.5),
                color.clone().lerp(new THREE.Color("#FFFFFF"), 0.6).multiplyScalar(0.5)
            ];
            updateColors();
            updateButtonGradients();
        });

        function updateColors() {
            lines.forEach((line, i) => {
                if (line.material) line.material.color = colors[i % colors.length];
            });
            sparkles.forEach((sparkle, i) => {
                if (sparkle) sparkle.color = colors[i % colors.length];
            });
            updateSparklesGeometry();
            let tempGalaxyColors = [];
            stars.forEach((star, i) => {
                if (star) {
                    star.color = galaxyColors[i % galaxyColors.length];
                    tempGalaxyColors.push(star.color.r, star.color.g, star.color.b);
                }
            });
            if (starsGeometry) {
                starsGeometry.setAttribute(
                    "color",
                    new THREE.Float32BufferAttribute(tempGalaxyColors, 3)
                );
            }
        }

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let targetZoom = camera.position.z;

        function handleKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyE': moveUp = true; break;
                case 'KeyQ': moveDown = true; break;
                case 'NumpadAdd':
                case 'Equal': targetZoom -= 0.5; break;
                case 'NumpadSubtract':
                case 'Minus': targetZoom += 0.5; break;
            }
            targetZoom = Math.max(0.1, Math.min(10, targetZoom));
        }

        function handleKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyE': moveUp = false; break;
                case 'KeyQ': moveDown = false; break;
            }
        }

        function handleWheel(event) {
            targetZoom += event.deltaY * 0.01;
            targetZoom = Math.max(0.1, Math.min(10, targetZoom));
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        document.addEventListener('wheel', handleWheel);

        function updateCamera() {
            const speed = 0.05;
            if (moveForward) camera.position.z -= speed;
            if (moveBackward) camera.position.z += speed;
            if (moveLeft) camera.position.x -= speed;
            if (moveRight) camera.position.x += speed;
            if (moveUp) camera.position.y += speed;
            if (moveDown) camera.position.y -= speed;

            camera.position.z += (targetZoom - camera.position.z) * 0.08;
            camera.position.z = Math.max(0.1, Math.min(10, camera.position.z));
        }

        function dots() {
            if (!omText) return;
            sampler = new THREE.MeshSurfaceSampler(omText).build();

            for (let i = 0; i < 8; i++) {
                const linesMaterial = new THREE.LineBasicMaterial({
                    color: colors[i % 4],
                    transparent: true,
                    opacity: 1
                });
                const linesMesh = new THREE.Line(new THREE.BufferGeometry(), linesMaterial);
                linesMesh.coordinates = [];
                linesMesh.previous = null;
                lines.push(linesMesh);
                group.add(linesMesh);
            }
        }

        let safe = 0;
        const p1 = new THREE.Vector3();
        function nextDot(line) {
            let ok = false;
            safe = 0;
            const maxAttempts = 200 * animationSpeed;
            while (!ok && safe < maxAttempts) {
                sampler.sample(p1);
                if (line.previous && p1.distanceTo(line.previous) < 0.08) {
                    line.coordinates.push(p1.x, p1.y, p1.z);
                    line.previous = p1.clone();

                    if (sparkles.length < maxParticles) {
                        for (let i = 0; i < 1; i++) {
                            const spark = new Sparkle();
                            spark.setup(p1, line.material.color);
                            sparkles.push(spark);
                        }
                    }
                    ok = true;
                } else if (!line.previous) {
                    line.previous = p1.clone();
                }
                safe++;
            }
        }

        function updateSparklesGeometry() {
            const tempSparklesArraySizes = [];
            const tempSparklesArrayColors = [];
            const tempSparklesArrayPositions = [];
            for (let i = 0; i < sparkles.length; i++) {
                const s = sparkles[i];
                if (s) {
                    tempSparklesArraySizes.push(s.size);
                    tempSparklesArrayColors.push(s.color.r, s.color.g, s.color.b);
                    tempSparklesArrayPositions.push(s.x, s.y, s.z);
                }
            }
            sparklesGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(tempSparklesArrayPositions, 3)
            );
            sparklesGeometry.setAttribute(
                "color",
                new THREE.Float32BufferAttribute(tempSparklesArrayColors, 3)
            );
            sparklesGeometry.setAttribute(
                "size",
                new THREE.Float32BufferAttribute(tempSparklesArraySizes, 1)
            );
            sparklesGeometry.attributes.position.needsUpdate = true;
            sparklesGeometry.attributes.color.needsUpdate = true;
            sparklesGeometry.attributes.size.needsUpdate = true;
        }

        class Sparkle extends THREE.Vector3 {
            constructor() {
                super();
                this.age = 0;
                this.dead = false;
            }
            setup(origin, color) {
                this.x = origin.x;
                this.y = origin.y;
                this.z = origin.z;
                this.v = new THREE.Vector3();
                this.v.x = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.x *= Math.random() > 0.5 ? 1 : -1;
                this.v.y = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.y *= Math.random() > 0.5 ? 1 : -1;
                this.v.z = THREE.MathUtils.randFloat(0.001, 0.006) * animationSpeed;
                this.v.z *= Math.random() > 0.5 ? 1 : -1;

                this.size = Math.random() * 3 + 0.5 * pixelRatio;
                this.slowDown = 0.4 + Math.random() * 0.58;
                this.color = color;
            }
            update() {
                this.age++;
                if (this.age > 200 / animationSpeed) {
                    this.dead = true;
                    return;
                }
                if (Math.abs(this.v.x) > 0.001 || Math.abs(this.v.y) > 0.001 || Math.abs(this.v.z) > 0.001) {
                    this.add(this.v);
                    this.v.multiplyScalar(this.slowDown);
                }
            }
        }

        class Star {
            constructor() {
                this.r = Math.random() * 8 + 3;
                this.phi = Math.random() * Math.PI * 2;
                this.theta = Math.random() * Math.PI;
                this.v = new THREE.Vector2().random().subScalar(0.5).multiplyScalar(0.0007);
                this.size = Math.random() * 2.5 + 0.5 * pixelRatio;
            }
            setup(color) {
                this.color = color;
                this.updatePosition();
            }
            updatePosition() {
                this.x = this.r * Math.sin(this.phi) * Math.sin(this.theta);
                this.y = this.r * Math.cos(this.phi);
                this.z = this.r * Math.sin(this.phi) * Math.cos(this.theta);
            }
            update() {
                this.phi += this.v.x * 0.5;
                this.theta += this.v.y * 0.5;
                this.updatePosition();
            }
        }

        const stars = [];
        const galaxyGeometryVertices = [];
        const galaxyGeometryColors = [];
        const galaxyGeometrySizes = [];

        const starCount = window.innerWidth < 600 ? 600 : 1200;
        for (let i = 0; i < starCount; i++) {
            const star = new Star();
            star.setup(galaxyColors[Math.floor(Math.random() * galaxyColors.length)]);
            galaxyGeometryVertices.push(star.x, star.y, star.z);
            galaxyGeometryColors.push(star.color.r, star.color.g, star.color.b);
            galaxyGeometrySizes.push(star.size);
            stars.push(star);
        }
        const starsGeometry = new THREE.BufferGeometry();
        starsGeometry.setAttribute(
            "size",
            new THREE.Float32BufferAttribute(galaxyGeometrySizes, 1)
        );
        starsGeometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(galaxyGeometryColors, 3)
        );
        const galaxyPoints = new THREE.Points(starsGeometry, sparklesMaterial);
        scene.add(galaxyPoints);

        let _prev = 0;
        function render(a) {
            if (autoRotate) group.rotation.y += 0.001 * animationSpeed;
            galaxyPoints.rotation.y += 0.0005;

            if (a - _prev > 30 / animationSpeed) {
                lines.forEach((l) => {
                    if (sparkles.length < maxParticles) {
                        for (let i = 0; i < 1 * animationSpeed; i++) nextDot(l);
                    }
                    const tempVertices = new Float32Array(l.coordinates);
                    l.geometry.setAttribute(
                        "position",
                        new THREE.BufferAttribute(tempVertices, 3)
                    );
                    l.geometry.computeBoundingSphere();
                });
                sparkles = sparkles.filter(s => !s.dead);
                sparkles.forEach(s => s.update());
                updateSparklesGeometry();
                _prev = a;
            }

            const tempStarsArray = new Float32Array(stars.length * 3);
            for (let i = 0; i < stars.length; i++) {
                const s = stars[i];
                if (s) {
                    s.update();
                    tempStarsArray[i * 3] = s.x;
                    tempStarsArray[i * 3 + 1] = s.y;
                    tempStarsArray[i * 3 + 2] = s.z;
                }
            }
            starsGeometry.setAttribute(
                "position",
                new THREE.BufferAttribute(tempStarsArray, 3)
            );

            updateCamera();
            controls.update();
            composer.render();
        }

        renderer.setAnimationLoop(render);

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
        });

        const audio = document.getElementById('background-audio');
        function playAudio() {
            audio.play().catch(error => {
                console.log("Autoplay failed:", error);
                document.addEventListener('click', () => {
                    audio.play();
                }, { once: true });
            });
        }

        function showCustomAlert(message) {
            const alertMessage = document.getElementById('custom-alert-message');
            alertMessage.textContent = message;
            document.getElementById('custom-alert').classList.remove('hidden');
        }

        function hideCustomAlert() {
            document.getElementById('custom-alert').classList.add('hidden');
        }

        window.onload = function() {
            showCustomAlert(" Please enter a name and press the 'Submit' button to start the visualization.");
            addText('OM');
            playAudio();
        };
    </script>
</body>
</html>
